"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeRegistry = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _util = require("@polkadot/util");

var _utilCrypto = require("@polkadot/util-crypto");

var _DoNotConstruct = require("../codec/DoNotConstruct.cjs");

var _Json = require("../codec/Json.cjs");

var _Raw = require("../codec/Raw.cjs");

var _index = require("../extrinsic/signedExtensions/index.cjs");

var _Event = require("../generic/Event.cjs");

var baseTypes = _interopRequireWildcard(require("../index.types.cjs"));

var definitions = _interopRequireWildcard(require("../interfaces/definitions.cjs"));

var _index2 = require("../metadata/decorate/index.cjs");

var _index3 = require("../metadata/decorate/extrinsics/index.cjs");

var _Metadata = require("../metadata/Metadata.cjs");

var _index4 = require("../metadata/PortableRegistry/index.cjs");

var _createClass = require("./createClass.cjs");

var _createType = require("./createType.cjs");

var _lazy = require("./lazy.cjs");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const l = (0, _util.logger)('registry');

function valueToString(v) {
  return v.toString();
}

function getFieldArgs(lookup, fields) {
  const args = new Array(fields.length);

  for (let i = 0; i < fields.length; i++) {
    args[i] = lookup.getTypeDef(fields[i].type).type;
  }

  return args;
}

function clearRecord(record) {
  const keys = Object.keys(record);

  for (let i = 0; i < keys.length; i++) {
    delete record[keys[i]];
  }
}

function getVariantStringIdx(_ref) {
  let {
    index
  } = _ref;
  return index.toString();
} // create error mapping from metadata


function injectErrors(_, _ref2, version, result) {
  let {
    lookup,
    pallets
  } = _ref2;
  clearRecord(result);

  for (let i = 0; i < pallets.length; i++) {
    const {
      errors,
      index,
      name
    } = pallets[i];

    if (errors.isSome) {
      const sectionName = (0, _util.stringCamelCase)(name);
      (0, _util.lazyMethod)(result, version >= 12 ? index.toNumber() : i, () => (0, _lazy.lazyVariants)(lookup, errors.unwrap(), getVariantStringIdx, _ref3 => {
        let {
          docs,
          fields,
          index,
          name
        } = _ref3;
        return {
          args: getFieldArgs(lookup, fields),
          docs: docs.map(valueToString),
          fields,
          index: index.toNumber(),
          method: name.toString(),
          name: name.toString(),
          section: sectionName
        };
      }));
    }
  }
} // create event classes from metadata


function injectEvents(registry, _ref4, version, result) {
  let {
    lookup,
    pallets
  } = _ref4;
  const filtered = pallets.filter(_index2.filterEventsSome);
  clearRecord(result);

  for (let i = 0; i < filtered.length; i++) {
    const {
      events,
      index,
      name
    } = filtered[i];
    (0, _util.lazyMethod)(result, version >= 12 ? index.toNumber() : i, () => (0, _lazy.lazyVariants)(lookup, events.unwrap(), getVariantStringIdx, variant => {
      const meta = registry.createType('EventMetadataLatest', (0, _util.objectSpread)({}, variant, {
        args: getFieldArgs(lookup, variant.fields)
      }));
      return class extends _Event.GenericEventData {
        constructor(registry, value) {
          super(registry, value, meta, (0, _util.stringCamelCase)(name), variant.name.toString());
        }

      };
    }));
  }
} // create extrinsic mapping from metadata


function injectExtrinsics(registry, _ref5, version, result) {
  let {
    lookup,
    pallets
  } = _ref5;
  const filtered = pallets.filter(_index2.filterCallsSome);
  clearRecord(result);

  for (let i = 0; i < filtered.length; i++) {
    const {
      calls,
      index,
      name
    } = filtered[i];
    const sectionIndex = version >= 12 ? index.toNumber() : i;
    (0, _util.lazyMethod)(result, sectionIndex, () => (0, _lazy.lazyVariants)(lookup, calls.unwrap(), getVariantStringIdx, variant => (0, _index3.createCallFunction)(registry, lookup, variant, (0, _util.stringCamelCase)(name), sectionIndex)));
  }
} // extract additional properties from the metadata


function extractProperties(registry, metadata) {
  const original = registry.getChainProperties();
  const constants = (0, _index2.decorateConstants)(registry, metadata.asLatest, metadata.version);
  const ss58Format = constants.system && (constants.system.sS58Prefix || constants.system.ss58Prefix);

  if (!ss58Format) {
    return original;
  }

  const {
    tokenDecimals,
    tokenSymbol
  } = original || {};
  return registry.createType('ChainProperties', {
    ss58Format,
    tokenDecimals,
    tokenSymbol
  });
}

var _classes = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("classes");

var _definitions = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("definitions");

var _lookup = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("lookup");

var _metadata = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("metadata");

var _metadataVersion = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("metadataVersion");

var _metadataCalls = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("metadataCalls");

var _metadataErrors = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("metadataErrors");

var _metadataEvents = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("metadataEvents");

var _unknownTypes = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("unknownTypes");

var _chainProperties = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("chainProperties");

var _hasher = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("hasher");

var _knownDefaults = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("knownDefaults");

var _knownDefinitions = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("knownDefinitions");

var _knownTypes = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("knownTypes");

var _signedExtensions = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("signedExtensions");

var _userExtensions = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("userExtensions");

class TypeRegistry {
  constructor(createdAtHash) {
    Object.defineProperty(this, _classes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _definitions, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _lookup, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _metadata, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _metadataVersion, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _metadataCalls, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataErrors, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataEvents, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _unknownTypes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _chainProperties, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _hasher, {
      writable: true,
      value: _utilCrypto.blake2AsU8a
    });
    Object.defineProperty(this, _knownDefaults, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownDefinitions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownTypes, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _signedExtensions, {
      writable: true,
      value: _index.fallbackExtensions
    });
    Object.defineProperty(this, _userExtensions, {
      writable: true,
      value: void 0
    });
    this.createdAtHash = void 0;
    (0, _classPrivateFieldLooseBase2.default)(this, _knownDefaults)[_knownDefaults] = (0, _util.objectSpread)({
      Json: _Json.Json,
      Metadata: _Metadata.Metadata,
      PortableRegistry: _index4.PortableRegistry,
      Raw: _Raw.Raw
    }, baseTypes);
    (0, _classPrivateFieldLooseBase2.default)(this, _knownDefinitions)[_knownDefinitions] = definitions;
    this.init();

    if (createdAtHash) {
      this.createdAtHash = this.createType('Hash', createdAtHash);
    }
  }

  init() {
    // start clean
    (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions

    this.register((0, _classPrivateFieldLooseBase2.default)(this, _knownDefaults)[_knownDefaults]);
    const allKnown = Object.values((0, _classPrivateFieldLooseBase2.default)(this, _knownDefinitions)[_knownDefinitions]);

    for (let i = 0; i < allKnown.length; i++) {
      this.register(allKnown[i].types);
    }

    return this;
  }

  get chainDecimals() {
    var _classPrivateFieldLoo;

    if ((_classPrivateFieldLoo = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome) {
      const allDecimals = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap();

      if (allDecimals.length) {
        return allDecimals.map(b => b.toNumber());
      }
    }

    return [12];
  }

  get chainSS58() {
    var _classPrivateFieldLoo2;

    return (_classPrivateFieldLoo2 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;
  }

  get chainTokens() {
    var _classPrivateFieldLoo3;

    if ((_classPrivateFieldLoo3 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome) {
      const allTokens = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap();

      if (allTokens.length) {
        return allTokens.map(valueToString);
      }
    }

    return [_util.formatBalance.getDefaults().unit];
  }
  /**
   * @description Returns tru if the type is in a Compat format
   */


  isLookupType(value) {
    return /Lookup\d+$/.test(value);
  }
  /**
   * @description Creates a lookup string from the supplied id
   */


  createLookupType(lookupId) {
    return `Lookup${lookupId.toString()}`;
  }

  get knownTypes() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes];
  }

  get lookup() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _lookup)[_lookup] || this.metadata.lookup;
  }

  get metadata() {
    (0, _util.assert)((0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata], 'Metadata has not been set on this registry');
    return (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata];
  }

  get unknownTypes() {
    return [...(0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].keys()];
  }

  get signedExtensions() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions];
  }
  /**
   * @describe Creates an instance of the class
   */


  createClass(type) {
    return (0, _createClass.createClass)(this, type);
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createType(type) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }

    return this.createTypeUnsafe(type, params);
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createTypeUnsafe(type, params, options) {
    return (0, _createType.createTypeUnsafe)(this, type, params, options);
  } // find a specific call


  findMetaCall(callIndex) {
    const [section, method] = [callIndex[0], callIndex[1]];
    return (0, _util.assertReturn)((0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls][`${section}`] && (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls][`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);
  } // finds an error


  findMetaError(errorIndex) {
    const [section, method] = (0, _util.isU8a)(errorIndex) ? [errorIndex[0], errorIndex[1]] : [errorIndex.index.toNumber(), errorIndex.error.toNumber()];
    return (0, _util.assertReturn)((0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors][`${section}`] && (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors][`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);
  }

  findMetaEvent(eventIndex) {
    const [section, method] = [eventIndex[0], eventIndex[1]];
    return (0, _util.assertReturn)((0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents][`${section}`] && (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents][`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);
  }

  get(name, withUnknown, knownTypeDef) {
    let Type = (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].get(name); // we have not already created the type, attempt it


    if (!Type) {
      const definition = (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(name);

      let BaseType; // we have a definition, so create the class now (lazily)

      if (definition) {
        BaseType = (0, _createClass.createClass)(this, definition);
      } else if (knownTypeDef) {
        BaseType = (0, _createClass.constructTypeClass)(this, knownTypeDef);
      } else if (withUnknown) {
        l.warn(`Unable to resolve type ${name}, it will fail on construction`);

        (0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].set(name, true);

        BaseType = _DoNotConstruct.DoNotConstruct.with(name);
      }

      if (BaseType) {
        // NOTE If we didn't extend here, we would have strange artifacts. An example is
        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128
        // Additionally, we now pass through the registry, which is a link to ourselves
        Type = class extends BaseType {};

        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, Type);
      }
    }

    return Type;
  }

  getChainProperties() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties];
  }

  getClassName(Type) {
    // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of
    // items such as u32 & U32, we get the lowercase versions here... not quite as optimal
    // (previously this used to be a simple find & return)
    const names = [];

    for (const [name, Clazz] of (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].entries()) {
      if (Type === Clazz) {
        names.push(name);
      }
    } // both sort and reverse are done in-place


    names.sort().reverse();
    return names.length ? names[0] : undefined;
  }

  getDefinition(typeName) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(typeName);
  }

  getModuleInstances(specName, moduleName) {
    var _classPrivateFieldLoo4, _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;

    return (_classPrivateFieldLoo4 = (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes]) === null || _classPrivateFieldLoo4 === void 0 ? void 0 : (_classPrivateFieldLoo5 = _classPrivateFieldLoo4.typesBundle) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : (_classPrivateFieldLoo6 = _classPrivateFieldLoo5.spec) === null || _classPrivateFieldLoo6 === void 0 ? void 0 : (_classPrivateFieldLoo7 = _classPrivateFieldLoo6[specName]) === null || _classPrivateFieldLoo7 === void 0 ? void 0 : (_classPrivateFieldLoo8 = _classPrivateFieldLoo7.instances) === null || _classPrivateFieldLoo8 === void 0 ? void 0 : _classPrivateFieldLoo8[moduleName];
  }

  getOrThrow(name, msg) {
    const Clazz = this.get(name);
    (0, _util.assert)(Clazz, msg || `type ${name} not found`);
    return Clazz;
  }

  getOrUnknown(name) {
    return this.get(name, true);
  }

  getSignedExtensionExtra() {
    return (0, _index.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'payload', (0, _classPrivateFieldLooseBase2.default)(this, _userExtensions)[_userExtensions]);
  }

  getSignedExtensionTypes() {
    return (0, _index.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'extrinsic', (0, _classPrivateFieldLooseBase2.default)(this, _userExtensions)[_userExtensions]);
  }

  hasClass(name) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name);
  }

  hasDef(name) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].has(name);
  }

  hasType(name) {
    return !(0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));
  }

  hash(data) {
    return this.createType('CodecHash', (0, _classPrivateFieldLooseBase2.default)(this, _hasher)[_hasher](data));
  }

  // eslint-disable-next-line no-dupe-class-members
  register(arg1, arg2) {
    // NOTE Constructors appear as functions here
    if ((0, _util.isFunction)(arg1)) {
      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1.name, arg1);
    } else if ((0, _util.isString)(arg1)) {
      (0, _util.assert)((0, _util.isFunction)(arg2), () => `Expected class definition passed to '${arg1}' registration`);
      (0, _util.assert)(arg1 !== arg2.toString(), () => `Unable to register circular ${arg1} === ${arg1}`);

      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1, arg2);
    } else {
      this._registerObject(arg1);
    }
  }

  _registerObject(obj) {
    const entries = Object.entries(obj);

    for (let e = 0; e < entries.length; e++) {
      const [name, type] = entries[e];

      if ((0, _util.isFunction)(type)) {
        // This _looks_ a bit funny, but `typeof Clazz === 'function'
        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, type);
      } else {
        const def = (0, _util.isString)(type) ? type : (0, _util.stringify)(type);
        (0, _util.assert)(name !== def, () => `Unable to register circular ${name} === ${def}`); // we already have this type, remove the classes registered for it

        if ((0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name)) {
          (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].delete(name);
        }

        (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].set(name, def);
      }
    }
  } // sets the chain properties


  setChainProperties(properties) {
    if (properties) {
      (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties] = properties;
    }
  }

  setHasher(hasher) {
    (0, _classPrivateFieldLooseBase2.default)(this, _hasher)[_hasher] = hasher || _utilCrypto.blake2AsU8a;
  }

  setKnownTypes(knownTypes) {
    (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes] = knownTypes;
  }

  setLookup(lookup) {
    (0, _classPrivateFieldLooseBase2.default)(this, _lookup)[_lookup] = lookup;
  } // sets the metadata


  setMetadata(metadata, signedExtensions, userExtensions) {
    (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata] = metadata.asLatest;
    (0, _classPrivateFieldLooseBase2.default)(this, _metadataVersion)[_metadataVersion] = metadata.version;
    injectExtrinsics(this, (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata], (0, _classPrivateFieldLooseBase2.default)(this, _metadataVersion)[_metadataVersion], (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls]);
    injectErrors(this, (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata], (0, _classPrivateFieldLooseBase2.default)(this, _metadataVersion)[_metadataVersion], (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors]);
    injectEvents(this, (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata], (0, _classPrivateFieldLooseBase2.default)(this, _metadataVersion)[_metadataVersion], (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents]); // setup the available extensions

    this.setSignedExtensions(signedExtensions || ((0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata].extrinsic.version.gt(_util.BN_ZERO) // FIXME Use the extension and their injected types
    ? (0, _classPrivateFieldLooseBase2.default)(this, _metadata)[_metadata].extrinsic.signedExtensions.map(_ref6 => {
      let {
        identifier
      } = _ref6;
      return identifier.toString();
    }) : _index.fallbackExtensions), userExtensions); // setup the chain properties with format overrides

    this.setChainProperties(extractProperties(this, metadata));
  } // sets the available signed extensions


  setSignedExtensions() {
    let signedExtensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _index.fallbackExtensions;
    let userExtensions = arguments.length > 1 ? arguments[1] : undefined;
    (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions] = signedExtensions;
    (0, _classPrivateFieldLooseBase2.default)(this, _userExtensions)[_userExtensions] = userExtensions;
    const unknown = (0, _index.findUnknownExtensions)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], (0, _classPrivateFieldLooseBase2.default)(this, _userExtensions)[_userExtensions]);

    if (unknown.length) {
      l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);
    }
  }

}

exports.TypeRegistry = TypeRegistry;