"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructTypeClass = constructTypeClass;
exports.createClass = createClass;
exports.getTypeClass = getTypeClass;

var _util = require("@polkadot/util");

var _index = require("../codec/index.cjs");

var _index2 = require("../primitive/index.cjs");

var _getTypeDef = require("./getTypeDef.cjs");

var _types = require("./types.cjs");

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function getTypeDefType(_ref) {
  let {
    lookupName,
    type
  } = _ref;
  return lookupName || type;
}

function getSubDefArray(value) {
  (0, _util.assert)(value.sub && Array.isArray(value.sub), () => `Expected subtype as TypeDef[] in ${(0, _util.stringify)(value)}`);
  return value.sub;
}

function getSubDef(value) {
  (0, _util.assert)(value.sub && !Array.isArray(value.sub), () => `Expected subtype as TypeDef in ${(0, _util.stringify)(value)}`);
  return value.sub;
}

function getSubType(value) {
  return getTypeDefType(getSubDef(value));
} // create a maps of type string constructors from the input


function getTypeClassMap(value) {
  const subs = getSubDefArray(value);
  const map = {};

  for (let i = 0; i < subs.length; i++) {
    map[subs[i].name] = getTypeDefType(subs[i]);
  }

  return map;
} // create an array of type string constructors from the input


function getTypeClassArray(value) {
  return getSubDefArray(value).map(getTypeDefType);
}

function createInt(Clazz, _ref2) {
  let {
    displayName,
    length
  } = _ref2;
  (0, _util.assert)((0, _util.isNumber)(length), () => `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
  return Clazz.with(length, displayName);
}

function createHashMap(Clazz, value) {
  const [keyType, valueType] = getTypeClassArray(value);
  return Clazz.with(keyType, valueType);
}

function createWithSub(Clazz, value) {
  return Clazz.with(getSubType(value));
}

const infoMapping = {
  [_types.TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(_index.BTreeMap, value),
  [_types.TypeDefInfo.BTreeSet]: (registry, value) => createWithSub(_index.BTreeSet, value),
  [_types.TypeDefInfo.Compact]: (registry, value) => createWithSub(_index.Compact, value),
  [_types.TypeDefInfo.DoNotConstruct]: (registry, value) => _index.DoNotConstruct.with(value.displayName || value.type),
  [_types.TypeDefInfo.Enum]: (registry, value) => {
    const subs = getSubDefArray(value);
    return _index.Enum.with(subs.every(_ref3 => {
      let {
        type
      } = _ref3;
      return type === 'Null';
    }) ? subs.reduce((out, _ref4, count) => {
      let {
        index,
        name
      } = _ref4;
      out[name] = index || count;
      return out;
    }, {}) : getTypeClassMap(value));
  },
  [_types.TypeDefInfo.HashMap]: (registry, value) => createHashMap(_index.HashMap, value),
  [_types.TypeDefInfo.Int]: (registry, value) => createInt(_index.Int, value),
  // We have circular deps between Linkage & Struct
  [_types.TypeDefInfo.Linkage]: (registry, value) => {
    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys

    const Clazz = _index.Struct.with({
      previous: type,
      next: type
    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


    Clazz.prototype.toRawType = function () {
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
      return `Linkage<${this.next.toRawType(true)}>`;
    };

    return Clazz;
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [_types.TypeDefInfo.Null]: (registry, _) => _index2.Null,
  [_types.TypeDefInfo.Option]: (registry, value) => createWithSub(_index.Option, value),
  [_types.TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
  [_types.TypeDefInfo.Range]: (registry, value) => (value.type.includes('RangeInclusive') ? _index.RangeInclusive : _index.Range).with(getSubType(value)),
  [_types.TypeDefInfo.Result]: (registry, value) => {
    const [Ok, Err] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define

    return _index.Result.with({
      Err,
      Ok
    });
  },
  [_types.TypeDefInfo.Set]: (registry, value) => _index.CodecSet.with(getSubDefArray(value).reduce((result, _ref5) => {
    let {
      index,
      name
    } = _ref5;
    result[name] = index;
    return result;
  }, {}), value.length),
  [_types.TypeDefInfo.Si]: (registry, value) => getTypeClass(registry, registry.lookup.getTypeDef(value.type)),
  [_types.TypeDefInfo.Struct]: (registry, value) => _index.Struct.with(getTypeClassMap(value), value.alias),
  [_types.TypeDefInfo.Tuple]: (registry, value) => _index.Tuple.with(getTypeClassArray(value)),
  [_types.TypeDefInfo.UInt]: (registry, value) => createInt(_index.UInt, value),
  [_types.TypeDefInfo.Vec]: (registry, _ref6) => {
    let {
      sub
    } = _ref6;
    (0, _util.assert)(sub && !Array.isArray(sub), 'Expected type information for vector');
    return sub.type === 'u8' ? _index2.Bytes : _index.Vec.with(getTypeDefType(sub));
  },
  [_types.TypeDefInfo.VecFixed]: (registry, _ref7) => {
    let {
      displayName,
      length,
      sub
    } = _ref7;
    (0, _util.assert)(sub && (0, _util.isNumber)(length) && !Array.isArray(sub), 'Expected length & type information for fixed vector');
    return sub.type === 'u8' ? _index.U8aFixed.with(length * 8, displayName) : _index.VecFixed.with(getTypeDefType(sub), length);
  },
  [_types.TypeDefInfo.WrapperOpaque]: (registry, value) => createWithSub(_index.WrapperOpaque, value)
};

function constructTypeClass(registry, typeDef) {
  try {
    const Type = infoMapping[typeDef.info](registry, typeDef);
    (0, _util.assert)(Type, 'No class created'); // don't clobber any existing

    if (!Type.__fallbackType && typeDef.fallbackType) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore ...this is the only place we we actually assign this...
      Type.__fallbackType = typeDef.fallbackType;
    }

    return Type;
  } catch (error) {
    throw new Error(`Unable to construct class from ${(0, _util.stringify)(typeDef)}: ${error.message}`);
  }
} // Returns the type Class for construction


function getTypeClass(registry, typeDef) {
  return registry.get(typeDef.type, false, typeDef);
}

function createClass(registry, type) {
  return getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : (0, _getTypeDef.getTypeDef)(type));
}