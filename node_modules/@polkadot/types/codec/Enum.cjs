"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Enum = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _util = require("@polkadot/util");

var _Null = require("../primitive/Null.cjs");

var _index = require("./utils/index.cjs");

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function isRustEnum(def) {
  const defValues = Object.values(def);

  if (defValues.some(v => (0, _util.isNumber)(v))) {
    (0, _util.assert)(defValues.every(v => (0, _util.isNumber)(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');
    return false;
  }

  return true;
}

function extractDef(registry, _def) {
  const def = {};
  let isBasic;
  let isIndexed;

  if (Array.isArray(_def)) {
    for (let i = 0; i < _def.length; i++) {
      def[_def[i]] = {
        Type: _Null.Null,
        index: i
      };
    }

    isBasic = true;
    isIndexed = false;
  } else if (isRustEnum(_def)) {
    const entries = Object.entries((0, _index.mapToTypeMap)(registry, _def));

    for (let i = 0; i < entries.length; i++) {
      const [key, Type] = entries[i];
      def[key] = {
        Type,
        index: i
      };
    }

    isBasic = !Object.values(def).some(_ref => {
      let {
        Type
      } = _ref;
      return Type !== _Null.Null;
    });
    isIndexed = false;
  } else {
    const entries = Object.entries(_def);

    for (let i = 0; i < entries.length; i++) {
      const [key, index] = entries[i];
      def[key] = {
        Type: _Null.Null,
        index
      };
    }

    isBasic = true;
    isIndexed = true;
  }

  return {
    def,
    isBasic,
    isIndexed
  };
}

function createFromValue(registry, def) {
  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let value = arguments.length > 3 ? arguments[3] : undefined;
  const entry = Object.values(def).find(e => e.index === index);
  (0, _util.assert)(!(0, _util.isUndefined)(entry), () => `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);
  return {
    index,
    value: value instanceof entry.Type ? value : new entry.Type(registry, value)
  };
}

function decodeFromJSON(registry, def, key, value) {
  // JSON comes in the form of { "<type (camelCase)>": "<value for type>" }, here we
  // additionally force to lower to ensure forward compat
  const keys = Object.keys(def).map(k => k.toLowerCase());
  const keyLower = key.toLowerCase();
  const index = keys.indexOf(keyLower);
  (0, _util.assert)(index !== -1, () => `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);

  try {
    return createFromValue(registry, def, Object.values(def)[index].index, value);
  } catch (error) {
    throw new Error(`Enum(${key}):: ${error.message}`);
  }
}

function decodeEnum(registry, def, value, index) {
  // NOTE We check the index path first, before looking at values - this allows treating
  // the optional indexes before anything else, more-specific > less-specific
  if ((0, _util.isNumber)(index)) {
    return createFromValue(registry, def, index, value);
  } else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) {
    const u8a = (0, _util.u8aToU8a)(value); // nested, we don't want to match isObject below

    if (u8a.length) {
      return createFromValue(registry, def, u8a[0], u8a.subarray(1));
    }
  } else if (value instanceof Enum) {
    return createFromValue(registry, def, value.index, value.value);
  } else if ((0, _util.isNumber)(value)) {
    return createFromValue(registry, def, value);
  } else if ((0, _util.isString)(value)) {
    return decodeFromJSON(registry, def, value.toString());
  } else if ((0, _util.isObject)(value)) {
    const key = Object.keys(value)[0];
    return decodeFromJSON(registry, def, key, value[key]);
  } // Worst-case scenario, return the first with default


  return createFromValue(registry, def, Object.values(def)[0].index);
}
/**
 * @name Enum
 * @description
 * This implements an enum, that based on the value wraps a different type. It is effectively
 * an extension to enum where the value type is determined by the actual index.
 */


var _def2 = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("def");

var _entryIndex = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("entryIndex");

var _indexes = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("indexes");

var _isBasic = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("isBasic");

var _isIndexed = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("isIndexed");

var _raw = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("raw");

class Enum {
  constructor(registry, Types, value, index) {
    this.registry = void 0;
    this.createdAtHash = void 0;
    Object.defineProperty(this, _def2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _entryIndex, {
      writable: true,
      value: void 0
    });
    this.initialU8aLength = void 0;
    Object.defineProperty(this, _indexes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isBasic, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isIndexed, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _raw, {
      writable: true,
      value: void 0
    });
    const {
      def,
      isBasic,
      isIndexed
    } = extractDef(registry, Types); // shortcut isU8a as used in SCALE decoding

    const decoded = (0, _util.isU8a)(value) && value.length && !(0, _util.isNumber)(index) ? createFromValue(registry, def, value[0], value.subarray(1)) : decodeEnum(registry, def, value, index);
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2] = def;
    (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] = isBasic;
    (0, _classPrivateFieldLooseBase2.default)(this, _isIndexed)[_isIndexed] = isIndexed;
    (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes] = Object.values(def).map(_ref2 => {
      let {
        index
      } = _ref2;
      return index;
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _entryIndex)[_entryIndex] = (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes].indexOf(decoded.index) || 0;
    (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] = decoded.value;

    if ((0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].initialU8aLength) {
      this.initialU8aLength = 1 + (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].initialU8aLength;
    }
  }

  static with(Types) {
    const keys = Array.isArray(Types) ? Types : Object.keys(Types);
    const asKeys = new Array(keys.length);
    const isKeys = new Array(keys.length);

    for (let i = 0; i < keys.length; i++) {
      const name = (0, _util.stringPascalCase)(keys[i].replace(' ', '_'));
      asKeys[i] = `as${name}`;
      isKeys[i] = `is${name}`;
    }

    return class extends Enum {
      constructor(registry, value, index) {
        super(registry, Types, value, index);
        (0, _util.objectProperties)(this, isKeys, (_, i) => this.type === keys[i]);
        (0, _util.objectProperties)(this, asKeys, (k, i) => {
          (0, _util.assert)(this[isKeys[i]], () => `Cannot convert '${this.type}' via ${k}`);
          return this.value;
        });
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return 1 + (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].encodedLength;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description The index of the enum value
   */


  get index() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes][(0, _classPrivateFieldLooseBase2.default)(this, _entryIndex)[_entryIndex]];
  }
  /**
   * @description true if this is a basic enum (no values)
   */


  get isBasic() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic];
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].isEmpty;
  }
  /**
   * @description Checks if the Enum points to a [[Null]] type
   */


  get isNone() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] instanceof _Null.Null;
  }
  /**
   * @description Checks if the Enum points to a [[Null]] type
   * @deprecated use isNone
   */


  get isNull() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] instanceof _Null.Null;
  }
  /**
   * @description The available keys for this enum
   */


  get defIndexes() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes];
  }
  /**
   * @description The available keys for this enum
   */


  get defKeys() {
    return Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]);
  }
  /**
   * @description The name of the type this enum value represents
   */


  get type() {
    return this.defKeys[(0, _classPrivateFieldLooseBase2.default)(this, _entryIndex)[_entryIndex]];
  }
  /**
   * @description The value of the enum
   */


  get value() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw];
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    // cater for the case where we only pass the enum index
    if ((0, _util.isU8a)(other)) {
      return !this.toU8a().some((entry, index) => entry !== other[index]);
    } else if ((0, _util.isNumber)(other)) {
      return this.toNumber() === other;
    } else if ((0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] && (0, _util.isString)(other)) {
      return this.type === other;
    } else if ((0, _util.isHex)(other)) {
      return this.toHex() === other;
    } else if (other instanceof Enum) {
      return this.index === other.index && this.value.eq(other.value);
    } else if ((0, _util.isObject)(other)) {
      return this.value.eq(other[this.type]);
    } // compare the actual wrapper value


    return this.value.eq(other);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] || this.isNone ? this.type : {
      [this.type]: (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toHuman(isExtended)
    };
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] ? this.type : {
      [(0, _util.stringCamelCase)(this.type)]: (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toJSON()
    };
  }
  /**
   * @description Returns the number representation for the value
   */


  toNumber() {
    return this.index;
  }
  /**
   * @description Returns a raw struct representation of the enum types
   */


  _toRawStruct() {
    if ((0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic]) {
      return (0, _classPrivateFieldLooseBase2.default)(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce((out, key, index) => {
        out[key] = (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes][index];
        return out;
      }, {}) : this.defKeys;
    }

    const typeMap = Object.entries((0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]).reduce((out, _ref3) => {
      let [key, {
        Type
      }] = _ref3;
      out[key] = Type;
      return out;
    }, {});
    return (0, _index.typesToMap)(this.registry, typeMap);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return (0, _util.stringify)({
      _enum: this._toRawStruct()
    });
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this.isNull ? this.type : (0, _util.stringify)(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return (0, _util.u8aConcat)(new Uint8Array(isBare ? [] : [this.index]), (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toU8a(isBare));
  }

}

exports.Enum = Enum;