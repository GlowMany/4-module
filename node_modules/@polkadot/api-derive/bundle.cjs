"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  derive: true,
  getAvailableDerives: true,
  lazyDeriveSection: true,
  packageInfo: true
};
exports.derive = void 0;
exports.getAvailableDerives = getAvailableDerives;
Object.defineProperty(exports, "lazyDeriveSection", {
  enumerable: true,
  get: function () {
    return _lazy.lazyDeriveSection;
  }
});
Object.defineProperty(exports, "packageInfo", {
  enumerable: true,
  get: function () {
    return _packageInfo.packageInfo;
  }
});

var _lazy = require("./util/lazy.cjs");

var accounts = _interopRequireWildcard(require("./accounts/index.cjs"));

var balances = _interopRequireWildcard(require("./balances/index.cjs"));

var bounties = _interopRequireWildcard(require("./bounties/index.cjs"));

var chain = _interopRequireWildcard(require("./chain/index.cjs"));

var contracts = _interopRequireWildcard(require("./contracts/index.cjs"));

var council = _interopRequireWildcard(require("./council/index.cjs"));

var crowdloan = _interopRequireWildcard(require("./crowdloan/index.cjs"));

var democracy = _interopRequireWildcard(require("./democracy/index.cjs"));

var elections = _interopRequireWildcard(require("./elections/index.cjs"));

var imOnline = _interopRequireWildcard(require("./imOnline/index.cjs"));

var membership = _interopRequireWildcard(require("./membership/index.cjs"));

var parachains = _interopRequireWildcard(require("./parachains/index.cjs"));

var session = _interopRequireWildcard(require("./session/index.cjs"));

var society = _interopRequireWildcard(require("./society/index.cjs"));

var staking = _interopRequireWildcard(require("./staking/index.cjs"));

var technicalCommittee = _interopRequireWildcard(require("./technicalCommittee/index.cjs"));

var treasury = _interopRequireWildcard(require("./treasury/index.cjs"));

var tx = _interopRequireWildcard(require("./tx/index.cjs"));

var _packageInfo = require("./packageInfo.cjs");

var _index19 = require("./type/index.cjs");

Object.keys(_index19).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index19[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index19[key];
    }
  });
});

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const derive = {
  accounts,
  balances,
  bounties,
  chain,
  contracts,
  council,
  crowdloan,
  democracy,
  elections,
  imOnline,
  membership,
  parachains,
  session,
  society,
  staking,
  technicalCommittee,
  treasury,
  tx
};
exports.derive = derive;
// Enable derive only if some of these modules are available
const checks = {
  contracts: {
    instances: ['contracts'],
    methods: []
  },
  council: {
    instances: ['council'],
    methods: [],
    withDetect: true
  },
  crowdloan: {
    instances: ['crowdloan'],
    methods: []
  },
  democracy: {
    instances: ['democracy'],
    methods: []
  },
  elections: {
    instances: ['phragmenElection', 'electionsPhragmen', 'elections', 'council'],
    methods: [],
    withDetect: true
  },
  imOnline: {
    instances: ['imOnline'],
    methods: []
  },
  membership: {
    instances: ['membership'],
    methods: []
  },
  parachains: {
    instances: ['parachains', 'registrar'],
    methods: []
  },
  session: {
    instances: ['session'],
    methods: []
  },
  society: {
    instances: ['society'],
    methods: []
  },
  staking: {
    instances: ['staking'],
    methods: ['erasRewardPoints']
  },
  technicalCommittee: {
    instances: ['technicalCommittee'],
    methods: [],
    withDetect: true
  },
  treasury: {
    instances: ['treasury'],
    methods: []
  }
};

function getModuleInstances(api, specName, moduleName) {
  return api.registry.getModuleInstances(specName, moduleName) || [];
}
/**
 * Returns an object that will inject `api` into all the functions inside
 * `allSections`, and keep the object architecture of `allSections`.
 */

/** @internal */


function injectFunctions(instanceId, api, derives) {
  const result = {};
  const names = Object.keys(derives);
  const keys = Object.keys(api.query);
  const specName = api.runtimeVersion.specName.toString();

  const filterKeys = q => keys.includes(q);

  const filterInstances = q => getModuleInstances(api, specName, q).some(filterKeys);

  const filterMethods = all => m => all.some(q => keys.includes(q) && api.query[q][m]);

  const getKeys = s => Object.keys(derives[s]);

  const creator = (s, m) => derives[s][m](instanceId, api);

  const isIncluded = c => !checks[c] || checks[c].instances.some(filterKeys) && (!checks[c].methods.length || checks[c].methods.every(filterMethods(checks[c].instances))) || checks[c].withDetect && checks[c].instances.some(filterInstances);

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    isIncluded(name) && (0, _lazy.lazyDeriveSection)(result, name, getKeys, creator);
  }

  return result;
} // FIXME The return type of this function should be {...ExactDerive, ...DeriveCustom}
// For now we just drop the custom derive typings

/** @internal */


function getAvailableDerives(instanceId, api) {
  let custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return { ...injectFunctions(instanceId, api, derive),
    ...injectFunctions(instanceId, api, custom)
  };
}