"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClass = createClass;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _rxjs = require("rxjs");

var _util = require("@polkadot/util");

var _index = require("../util/index.cjs");

var _Result = require("./Result.cjs");

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable no-dupe-class-members */
const identity = input => input;

function makeEraOptions(api, registry, partialOptions, _ref) {
  let {
    header,
    mortalLength,
    nonce
  } = _ref;

  if (!header) {
    if ((0, _util.isNumber)(partialOptions.era)) {
      // since we have no header, it is immortal, remove any option overrides
      // so we only supply the genesisHash and no era to the construction
      delete partialOptions.era;
      delete partialOptions.blockHash;
    }

    return makeSignOptions(api, partialOptions, {
      nonce
    });
  }

  return makeSignOptions(api, partialOptions, {
    blockHash: header.hash,
    era: registry.createType('ExtrinsicEra', {
      current: header.number,
      period: partialOptions.era || mortalLength
    }),
    nonce
  });
}

function makeSignAndSendOptions(partialOptions, statusCb) {
  let options = {};

  if ((0, _util.isFunction)(partialOptions)) {
    statusCb = partialOptions;
  } else {
    options = (0, _util.objectSpread)({}, partialOptions);
  }

  return [options, statusCb];
}

function makeSignOptions(api, partialOptions, extras) {
  return (0, _util.objectSpread)({
    blockHash: api.genesisHash,
    genesisHash: api.genesisHash
  }, partialOptions, extras, {
    runtimeVersion: api.runtimeVersion,
    signedExtensions: api.registry.signedExtensions,
    version: api.extrinsicType
  });
}

function optionsOrNonce() {
  let partialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (0, _util.isBn)(partialOptions) || (0, _util.isNumber)(partialOptions) ? {
    nonce: partialOptions
  } : partialOptions;
}

function createClass(_ref2) {
  let {
    api,
    apiType,
    decorateMethod
  } = _ref2;
  // an instance of the base extrinsic for us to extend
  const ExtrinsicBase = api.registry.createClass('Extrinsic');

  var _ignoreStatusCb = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("ignoreStatusCb");

  var _transformResult = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("transformResult");

  var _observeSign = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("observeSign");

  var _observeStatus = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("observeStatus");

  var _observeSend = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("observeSend");

  var _observeSubscribe = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("observeSubscribe");

  var _signViaSigner = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("signViaSigner");

  var _updateSigner = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("updateSigner");

  class Submittable extends ExtrinsicBase {
    constructor(registry, extrinsic) {
      var _this;

      super(registry, extrinsic, {
        version: api.extrinsicType
      });
      _this = this;
      Object.defineProperty(this, _ignoreStatusCb, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _transformResult, {
        writable: true,
        value: identity
      });
      Object.defineProperty(this, _observeSign, {
        writable: true,
        value: (account, partialOptions) => {
          const address = (0, _index.isKeyringPair)(account) ? account.address : account.toString();
          const options = optionsOrNonce(partialOptions);
          let updateId;
          return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, _rxjs.first)(), (0, _rxjs.mergeMap)(async signingInfo => {
            const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);

            if ((0, _index.isKeyringPair)(account)) {
              this.sign(account, eraOptions);
            } else {
              updateId = await (0, _classPrivateFieldLooseBase2.default)(this, _signViaSigner)[_signViaSigner](address, eraOptions, signingInfo.header);
            }
          }), (0, _rxjs.mapTo)(updateId));
        }
      });
      Object.defineProperty(this, _observeStatus, {
        writable: true,
        value: (hash, status) => {
          if (!status.isFinalized && !status.isInBlock) {
            return (0, _rxjs.of)((0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult](new _Result.SubmittableResult({
              status
            })));
          }

          const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;
          return api.derive.tx.events(blockHash).pipe((0, _rxjs.map)(_ref3 => {
            let {
              block,
              events
            } = _ref3;
            return (0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult](new _Result.SubmittableResult({
              events: (0, _index.filterEvents)(hash, block, events, status),
              status
            }));
          }), (0, _rxjs.catchError)(internalError => (0, _rxjs.of)((0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult](new _Result.SubmittableResult({
            internalError,
            status
          })))));
        }
      });
      Object.defineProperty(this, _observeSend, {
        writable: true,
        value: function () {
          let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
          return api.rpc.author.submitExtrinsic(_this).pipe((0, _rxjs.tap)(hash => {
            (0, _classPrivateFieldLooseBase2.default)(_this, _updateSigner)[_updateSigner](updateId, hash);
          }));
        }
      });
      Object.defineProperty(this, _observeSubscribe, {
        writable: true,
        value: function () {
          let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
          const hash = _this.hash;
          return api.rpc.author.submitAndWatchExtrinsic(_this).pipe((0, _rxjs.switchMap)(status => (0, _classPrivateFieldLooseBase2.default)(_this, _observeStatus)[_observeStatus](hash, status)), (0, _rxjs.tap)(status => {
            (0, _classPrivateFieldLooseBase2.default)(_this, _updateSigner)[_updateSigner](updateId, status);
          }));
        }
      });
      Object.defineProperty(this, _signViaSigner, {
        writable: true,
        value: async (address, options, header) => {
          const signer = options.signer || api.signer;
          (0, _util.assert)(signer, 'No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
          const payload = this.registry.createType('SignerPayload', (0, _util.objectSpread)({}, options, {
            address,
            blockNumber: header ? header.number : 0,
            method: this.method
          }));
          let result;

          if (signer.signPayload) {
            result = await signer.signPayload(payload.toPayload());
          } else if (signer.signRaw) {
            result = await signer.signRaw(payload.toRaw());
          } else {
            throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');
          } // Here we explicitly call `toPayload()` again instead of working with an object
          // (reference) as passed to the signer. This means that we are sure that the
          // payload data is not modified from our inputs, but the signer


          super.addSignature(address, result.signature, payload.toPayload());
          return result.id;
        }
      });
      Object.defineProperty(this, _updateSigner, {
        writable: true,
        value: (updateId, status) => {
          if (updateId !== -1 && api.signer && api.signer.update) {
            api.signer.update(updateId, status);
          }
        }
      });
      (0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] = apiType === 'rxjs';
    } // dry run an extrinsic


    dryRun(account, optionsOrHash) {
      if ((0, _util.isString)(optionsOrHash) || (0, _util.isU8a)(optionsOrHash)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), optionsOrHash));
      } // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call


      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, optionsOrHash).pipe((0, _rxjs.switchMap)(() => api.rpc.system.dryRun(this.toHex()))))();
    } // calculate the payment info for this transaction (if signed and submitted)


    paymentInfo(account, optionsOrHash) {
      if ((0, _util.isString)(optionsOrHash) || (0, _util.isU8a)(optionsOrHash)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod(() => api.rpc.payment.queryInfo(this.toHex(), optionsOrHash));
      }

      const [allOptions] = makeSignAndSendOptions(optionsOrHash);
      const address = (0, _index.isKeyringPair)(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, _rxjs.first)(), (0, _rxjs.switchMap)(signingInfo => {
        // setup our options (same way as in signAndSend)
        const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);
        const signOptions = makeSignOptions(api, eraOptions, {});
        this.signFake(address, signOptions);
        return api.rpc.payment.queryInfo(this.toHex());
      })))();
    } // send with an immediate Hash result


    // send implementation for both immediate Hash and statusCb variants
    send(statusCb) {
      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe] : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend])(statusCb);
    }
    /**
     * @description Sign a transaction, returning the this to allow chaining, i.e. .sign(...).send(). When options, e.g. nonce/blockHash are not specified, it will be inferred. To retrieve eg. nonce use `signAsync` (the preferred interface, this is provided for backwards compatibility)
     * @deprecated
     */


    sign(account, partialOptions) {
      super.sign(account, makeSignOptions(api, optionsOrNonce(partialOptions), {}));
      return this;
    }
    /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */


    signAsync(account, partialOptions) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, partialOptions).pipe((0, _rxjs.mapTo)(this)))();
    } // signAndSend with an immediate Hash result


    // signAndSend implementation for all 3 cases above
    signAndSend(account, partialOptions, optionalStatusCb) {
      const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);
      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, options).pipe((0, _rxjs.switchMap)(updateId => isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe](updateId) : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend](updateId))) // FIXME This is wrong, SubmittableResult is _not_ a codec
      )(statusCb);
    } // adds a transform to the result, applied before result is returned


    withResultTransform(transform) {
      (0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult] = transform;
      return this;
    }

  }

  return Submittable;
}