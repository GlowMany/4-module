"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hkdf = exports.hkdf_expand = exports.hkdf_extract = void 0;
// prettier-ignore
const utils_js_1 = require("./utils.js");
const hmac_js_1 = require("./hmac.js");
// HKDF (RFC 5869)
// HKDF-Extract(IKM, salt) -> PRK NOTE: arguments position differs from spec (IKM is first one, since it is not optional)
function hkdf_extract(hash, ikm, salt) {
    (0, utils_js_1.assertHash)(hash);
    // NOTE: some libraries treats zero-length array as 'not provided', we don't, since we have undefined as 'not provided'
    // More info: https://github.com/RustCrypto/KDFs/issues/15
    if (salt === undefined)
        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros
    return (0, hmac_js_1.hmac)(hash, (0, utils_js_1.toBytes)(salt), (0, utils_js_1.toBytes)(ikm));
}
exports.hkdf_extract = hkdf_extract;
// HKDF-Expand(PRK, info, L) -> OKM
const HKDF_COUNTER = new Uint8Array([0]);
const EMPTY_BUFFER = new Uint8Array();
function hkdf_expand(hash, prk, // a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
info, // optional context and application specific information (can be a zero-length string)
length = 32 // length of output keying material in octets
) {
    (0, utils_js_1.assertHash)(hash);
    (0, utils_js_1.assertNumber)(length);
    if (length > 255 * hash.outputLen)
        throw new Error('Length should be <= 255*HashLen');
    const blocks = Math.ceil(length / hash.outputLen);
    if (info === undefined)
        info = EMPTY_BUFFER;
    // first L(ength) octets of T
    const okm = new Uint8Array(blocks * hash.outputLen);
    // Re-use HMAC instance between blocks
    const HMAC = hmac_js_1.hmac.init(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
        HKDF_COUNTER[0] = counter + 1;
        // T(0) = empty string (zero length)
        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)
        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)
            .update(info)
            .update(HKDF_COUNTER)
            .digestInto(T);
        okm.set(T, hash.outputLen * counter);
        HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    T.fill(0);
    return okm.slice(0, length);
}
exports.hkdf_expand = hkdf_expand;
// Extract+Expand
const hkdf = (hash, ikm, salt, info, length) => hkdf_expand(hash, hkdf_extract(hash, ikm, salt), info, length);
exports.hkdf = hkdf;
