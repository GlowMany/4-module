"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const entities_1 = require("./entities");
const schema_1 = require("./schema");
describe('utils that handle schema.graphql', () => {
    it('support @entity annotation in the schema', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type KittyBirthInfo @entity {
        id: ID!
        birthBlockHeight: BigInt!
        owner: String!
        birthAt: Date!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        expect(schema).toBeTruthy();
        expect(Object.keys(schema.getTypeMap())).toContain('KittyBirthInfo');
    });
    it('can extract entities from the schema', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type KittyBirthInfo @entity {
        id: ID!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const entities = (0, entities_1.getAllEntitiesRelations)(schema);
        expect(entities.models).toMatchObject([{ name: 'KittyBirthInfo' }]);
        expect(entities.models[0].fields).toEqual([
            { isArray: false, name: 'id', nullable: false, type: 'ID', isEnum: false },
        ]);
    });
    it('throw error for unsupported types', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Test @entity {
        id: ID!
        price: Double
      }
    `;
        expect(() => (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema)).toThrow();
    });
    it('support Bytes and Float types', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Test @entity {
        id: ID!
        hash: Bytes
        rate: Float
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const entities = (0, entities_1.getAllEntitiesRelations)(schema);
        expect(entities.models[0].fields[1].type).toBe('Bytes');
        expect(entities.models[0].fields[2].type).toBe('Float');
    });
    it('throw error for union/enum/interface type', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Test @entity {
        id: ID!
        unionKind: unionResult
        enumKind: enumResult
        who: Character
      }
      interface Character {
        id: ID!
        name: String!
      }
      union unionResult = Human | Droid | Starship
      type Human @entity {
        id: ID!
      }
      type Droid @entity {
        id: ID!
      }
      type Starship @entity {
        id: ID!
      }
      enum enumResult {
        NEWHOPE
        EMPIRE
        JEDI
      }
    `;
        expect(() => {
            const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
            (0, entities_1.getAllEntitiesRelations)(schema);
        }).toThrow(/Not support/);
    });
    it('can extract nested models and relations from the schema', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Account @entity {
        id: ID!
        identity: Identity! @derivedFrom(field: "account")
        transfers: [Transfer] @derivedFrom(field: "from")
      }
      type Transfer @entity {
        id: ID!
        from: Account!
      }
      type Identity @entity {
        id: ID!
        account: Account!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const entities = (0, entities_1.getAllEntitiesRelations)(schema);
        expect(entities.models).toMatchObject([
            {
                name: 'Account',
                fields: [{ name: 'id', type: 'ID', isArray: false, nullable: false }],
            },
            {
                name: 'Transfer',
                fields: [
                    { name: 'id', type: 'ID', isArray: false, nullable: false },
                    { name: 'fromId', type: 'String', isArray: false, nullable: false },
                ],
            },
            {
                name: 'Identity',
                fields: [
                    { name: 'id', type: 'ID', isArray: false, nullable: false },
                    {
                        name: 'accountId',
                        type: 'String',
                        isArray: false,
                        nullable: false,
                    },
                ],
            },
        ]);
        expect(entities.relations).toMatchObject([
            {
                from: 'Account',
                type: 'hasOne',
                to: 'Identity',
                foreignKey: 'accountId',
                fieldName: 'identity',
            },
            {
                from: 'Account',
                type: 'hasMany',
                to: 'Transfer',
                foreignKey: 'fromId',
                fieldName: 'transfers',
            },
            {
                from: 'Transfer',
                type: 'belongsTo',
                to: 'Account',
                foreignKey: 'fromId',
            },
            {
                from: 'Identity',
                type: 'belongsTo',
                to: 'Account',
                foreignKey: 'accountId',
            },
        ]);
    });
    it('throw error if derivedFrom field with missing field name in corresponding entity', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Account @entity {
        id: ID!
        transfers: [Transfer] @derivedFrom(field: "from")
      }
      type Transfer @entity {
        id: ID!
        #from: Account! # If this is missing
        to: Account!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        expect(() => (0, entities_1.getAllEntitiesRelations)(schema)).toThrow('Please check entity Account with field transfers has correct relation with entity Transfer');
    });
    it('can extract indexed fields from the schema', () => {
        var _a, _b, _c, _d, _e;
        const graphqlSchema = (0, graphql_tag_1.default) `
      type TestEntity @entity {
        id: ID!
        column1: String @index
        column2: BigInt @index(unique: true)
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const entities = (0, entities_1.getAllEntitiesRelations)(schema);
        expect((_a = entities.models) === null || _a === void 0 ? void 0 : _a[0].indexes).toHaveLength(2);
        expect((_b = entities.models) === null || _b === void 0 ? void 0 : _b[0].indexes[0].fields).toEqual(['column1']);
        expect((_c = entities.models) === null || _c === void 0 ? void 0 : _c[0].indexes[0].unique).toBeUndefined();
        expect((_d = entities.models) === null || _d === void 0 ? void 0 : _d[0].indexes[1].fields).toEqual(['column2']);
        expect((_e = entities.models) === null || _e === void 0 ? void 0 : _e[0].indexes[1].unique).toBe(true);
    });
    it('throw if add index on pk', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type TestEntity @entity {
        id: ID! @index
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        expect(() => (0, entities_1.getAllEntitiesRelations)(schema)).toThrow(/^index can not be added on field id/);
    });
    it('can extract indexed fields from foreign field', () => {
        var _a, _b, _c, _d, _e, _f;
        const graphqlSchema = (0, graphql_tag_1.default) `
      type Fruit @entity {
        id: ID!
        apple: Apple
        banana: [Banana] @index(unique: true)
      }
      type Fruit2 @entity {
        id: ID!
        apple: Apple @index
      }
      type Apple @entity {
        id: ID!
      }
      type Banana @entity {
        id: ID!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const entities = (0, entities_1.getAllEntitiesRelations)(schema);
        expect((_a = entities.models) === null || _a === void 0 ? void 0 : _a[0].indexes[0].fields).toEqual(['appleId']);
        expect((_b = entities.models) === null || _b === void 0 ? void 0 : _b[0].indexes[0].using).toEqual('hash');
        expect((_c = entities.models) === null || _c === void 0 ? void 0 : _c[0].indexes[0].unique).toBe(false);
        expect((_d = entities.models) === null || _d === void 0 ? void 0 : _d[0].indexes[1].unique).toBe(true);
        expect((_e = entities.models) === null || _e === void 0 ? void 0 : _e[1].indexes[0].fields).toEqual(['appleId']);
        expect((_f = entities.models) === null || _f === void 0 ? void 0 : _f[1].indexes[0].unique).toBe(false);
    });
    it('can read jsonfield', () => {
        const graphqlSchema = (0, graphql_tag_1.default) `
      type MyJson @jsonField {
        data: String!
        data2: [String]
        data3: MyJson2
      }
      type MyJson2 @jsonField {
        data4: String!
      }
      type Account @entity {
        field6: [MyJson]!
      }
    `;
        const schema = (0, schema_1.buildSchemaFromDocumentNode)(graphqlSchema);
        const accountModel = (0, entities_1.getAllEntitiesRelations)(schema).models.find((model) => model.name === 'Account');
        expect(accountModel.fields[0].type).toBe('Json');
        expect(accountModel.fields[0].jsonInterface.name).toBe('MyJson');
        expect(accountModel.fields[0].isArray).toBeTruthy();
        expect(accountModel.fields[0].jsonInterface.fields[0].nullable).toBeFalsy();
        expect(accountModel.fields[0].jsonInterface.fields[1].isArray).toBeTruthy();
        // allow json in json
        expect(accountModel.fields[0].jsonInterface.fields[2].type).toBe('Json');
        expect(accountModel.fields[0].jsonInterface.fields[2].jsonInterface.name).toBe('MyJson2');
    });
});
//# sourceMappingURL=graphql.spec.js.map