"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const common_1 = require("@subql/common");
const readers_1 = require("./readers");
const rules_1 = require("./rules");
class Validator {
    constructor(location, opts) {
        this.location = location;
        this.rules = [];
        this.reader = readers_1.ReaderFactory.create(location, opts);
    }
    addRule(...rules) {
        this.rules.push(...rules);
    }
    async getValidateReports() {
        const reports = [];
        const [pkg, rawSchema] = await Promise.all([this.reader.getPkg(), this.reader.getProjectSchema()]);
        if (!rawSchema) {
            throw new Error('Not a valid SubQuery project, project.yaml is missing');
        }
        reports.push({
            name: 'project-yaml-file',
            description: 'A valid `project.yaml` file must exist in the root directory of the project',
            valid: !!rawSchema,
            skipped: false,
        });
        const schema = new common_1.ProjectManifestVersioned(rawSchema);
        if (schema.isV0_0_1) {
            reports.push({
                name: 'package-json-file',
                description: 'A valid `package.json` file must exist in the root directory of the project',
                valid: !!pkg,
                skipped: false,
            });
        }
        const ctx = {
            data: {
                projectPath: this.location,
                pkg,
                schema,
            },
            logger: console,
            reader: this.reader,
        };
        for (const r of this.rules) {
            const report = {
                name: r.name,
                description: r.description,
                valid: false,
                skipped: false,
            };
            if ((!pkg && r.type === rules_1.RuleType.PackageJSON) || (!schema && r.type === rules_1.RuleType.Schema)) {
                report.skipped = true;
            }
            else {
                report.valid = await r.validate(ctx);
            }
            reports.push(report);
        }
        return reports;
    }
    async validate() {
        const reports = await this.getValidateReports();
        return !reports.some((r) => !r.valid);
    }
}
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map