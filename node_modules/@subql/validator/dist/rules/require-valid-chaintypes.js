"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const common_1 = require("@subql/common");
const rule_1 = require("./rule");
class RequireValidChainTypes {
    constructor() {
        this.type = rule_1.RuleType.Schema;
        this.name = 'require-valid-chaintypes';
        this.description = 'Specified chain types file must match the polkadot RegistryTypes';
    }
    async validate(ctx) {
        var _a;
        if (ctx.data.schema.isV0_0_1)
            return true;
        const schema = ctx.data.schema.asV0_2_0;
        // No chain types to validate
        if (!((_a = schema.network.chaintypes) === null || _a === void 0 ? void 0 : _a.file))
            return true;
        //TODO, skip validate if chaintype is js format for now
        const { ext } = path_1.default.parse(schema.network.chaintypes.file);
        if (ext === '.js' || ext === '.cjs')
            return true;
        try {
            const rawChainTypes = await ctx.reader.getFile(schema.network.chaintypes.file);
            (0, common_1.parseChainTypes)(rawChainTypes);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
exports.default = RequireValidChainTypes;
//# sourceMappingURL=require-valid-chaintypes.js.map